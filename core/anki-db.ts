import initSqlJs from 'sql.js';
import {AnkiCard, AnkiNoteType} from './types';

// Constants for Anki Database
const ANKI_SEP = '\x1f'; // Unit separator for fields

/**
 * Generates the SQLite database (collection.anki2) required for an .apkg file.
 */
export const createAnkiDatabase = async (
  cards: AnkiCard[],
  deckName: string,
  noteType: AnkiNoteType,
  creationTime: number // New parameter to synchronize filenames
): Promise<Uint8Array> => {
  const SQL = await initSqlJs({
    locateFile: (file) => {
      // Check if we're in a Tauri environment
      // @ts-ignore
      const isTauri = typeof window !== 'undefined' && (window.__TAURI_INTERNALS__ || window.__TAURI__);

      if (isTauri) {
        // Tauri environment - use assets from public directory
        // This assumes WASM files are copied to public/sql.js/ during build
        return `/sql.js/${file}`;
      } else {
        // Web environment - use CDN
        return `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/${file}`;
      }
    }
  });

  const db = new SQL.Database();

  // 1. Create Schema
  db.run(`
    CREATE TABLE col
    (
      id     integer primary key,
      crt    integer not null,
      mod    integer not null,
      scm    integer not null,
      ver    integer not null,
      dty    integer not null,
      usn    integer not null,
      ls     integer not null,
      conf   text    not null,
      models text    not null,
      decks  text    not null,
      dconf  text    not null,
      tags   text    not null
    );
    CREATE TABLE notes
    (
      id    integer primary key,
      guid  text    not null,
      mid   integer not null,
      mod   integer not null,
      usn   integer not null,
      tags  text    not null,
      flds  text    not null,
      sfld  integer not null,
      csum  integer not null,
      flags integer not null,
      data  text    not null
    );
    CREATE TABLE cards
    (
      id     integer primary key,
      nid    integer not null,
      did    integer not null,
      ord    integer not null,
      mod    integer not null,
      usn    integer not null,
      type   integer not null,
      queue  integer not null,
      due    integer not null,
      ivl    integer not null,
      factor integer not null,
      reps   integer not null,
      lapses integer not null,
      left   integer not null,
      odue   integer not null,
      odid   integer not null,
      flags  integer not null,
      data   text    not null
    );
    CREATE TABLE revlog
    (
      id      integer primary key,
      cid     integer not null,
      usn     integer not null,
      ease    integer not null,
      ivl     integer not null,
      lastIvl integer not null,
      factor  integer not null,
      time    integer not null,
      type    integer not null
    );
    CREATE TABLE graves
    (
      usn  integer not null,
      oid  integer not null,
      type integer not null
    );
    ANALYZE
    sqlite_master;
  `);

  // 2. Create Deck Configuration (dconf) and Decks
  // Use creationTime for deck ID as well for consistency, though not strictly required
  const deckId = creationTime;
  const finalDeckName = deckName || "Sub2Anki Export";

  const decks = {
    [deckId]: {
      id: deckId,
      mod: Math.floor(creationTime / 1000),
      name: finalDeckName,
      usn: -1,
      lrnToday: [0, 0],
      revToday: [0, 0],
      newToday: [0, 0],
      timeToday: [0, 0],
      collapsed: false,
      browserCollapsed: false,
      desc: "Generated by Sub2Anki AI",
      dyn: 0,
      conf: 1,
      extendNew: 10,
      extendRev: 50
    },
    // Default deck needed
    1: {
      id: 1,
      name: "Default",
      conf: 1,
      mod: 0,
      usn: 0,
      desc: "",
      dyn: 0,
      collapsed: false,
      browserCollapsed: false,
      extendNew: 10,
      extendRev: 50,
      newToday: [0, 0],
      revToday: [0, 0],
      lrnToday: [0, 0],
      timeToday: [0, 0]
    }
  };

  const dconf = {
    1: {
      id: 1,
      mod: 0,
      name: "Default",
      usn: 0,
      maxTaken: 60,
      autoplay: true,
      timer: 0,
      replayq: true,
      new: {bury: false, delays: [1, 10], initialFactor: 2500, ints: [1, 4, 7], order: 1, perDay: 20},
      rev: {bury: false, ease4: 1.3, fuzz: 0.05, ivlFct: 1, maxIvl: 36500, minSpace: 1, perDay: 200},
      lapse: {delays: [10], leechAction: 0, leechFails: 8, minInt: 1, mult: 0}
    }
  };

  // 3. Create Model (Note Type) Configuration
  // Anki requires specific structure for fields and templates
  const flds = noteType.fields.map((f, i) => ({
    name: f.name,
    ord: i,
    sticky: false,
    rtl: false,
    font: "Arial",
    size: 20,
    media: []
  }));

  const tmpls = noteType.templates.map((t, i) => ({
    name: t.Name,
    ord: i,
    qfmt: t.Front,
    afmt: t.Back,
    bqfmt: "",
    bafmt: "",
    did: null
  }));

  const models = {
    [noteType.id]: {
      id: noteType.id,
      name: noteType.name,
      type: 0,
      mod: Math.floor(creationTime / 1000),
      usn: -1,
      sortf: 0,
      did: deckId,
      tmpls: tmpls,
      flds: flds,
      css: noteType.css,
      latexPre: "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
      latexPost: "\\end{document}",
      tags: [],
      req: [[0, "all", [0]]] // Require first field to be non-empty
    }
  };

  // 4. Insert Collection
  const colStmt = db.prepare(`INSERT INTO col
                              VALUES (:id, :crt, :mod, :scm, :ver, :dty, :usn, :ls, :conf, :models, :decks, :dconf,
                                      :tags)`);
  colStmt.run({
    ':id': 1,
    ':crt': Math.floor(creationTime / 1000),
    ':mod': Math.floor(creationTime / 1000),
    ':scm': Math.floor(creationTime / 1000),
    ':ver': 11,
    ':dty': 0,
    ':usn': 0,
    ':ls': 0,
    ':conf': "{}",
    ':models': JSON.stringify(models),
    ':decks': JSON.stringify(decks),
    ':dconf': JSON.stringify(dconf),
    ':tags': "{}"
  });
  colStmt.free();

  // 5. Insert Notes and Cards
  const noteStmt = db.prepare(`INSERT INTO notes
                               VALUES (:id, :guid, :mid, :mod, :usn, :tags, :flds, :sfld, :csum, :flags, :data)`);
  const cardStmt = db.prepare(`INSERT INTO cards
                               VALUES (:id, :nid, :did, :ord, :mod, :usn, :type, :queue, :due, :ivl, :factor, :reps,
                                       :lapses, :left, :odue, :odid, :flags, :data)`);

  // Use the passed creationTime to ensure filenames match what is in the zip media map
  cards.forEach((card, index) => {
    // Generate filenames for media
    // Note: We check if refs exist, not raw data
    const usedImageFilename = card.screenshotRef ? `sub2anki_${index}_${creationTime}.jpg` : '';

    // Force max height to 270px for images in the Media field
    const imageTag = usedImageFilename ? `<img src="${usedImageFilename}" style="max-height: 270px;" alt="${usedImageFilename}">` : '';

    const safeAudioFilename = card.audioRef ? `sub2anki_audio_${index}_${creationTime}.wav` : '';
    const audioTag = safeAudioFilename ? `[sound:${safeAudioFilename}]` : '';

    // Prepare fields array based on the model definition and mappings
    const fieldValues: string[] = noteType.fields.map(f => {
      // Use explicit mapping if available
      if (f.source) {
        switch (f.source) {
          case 'Text':
            return card.text;
          case 'Translation':
            return card.translation;
          case 'Notes':
            return card.notes;
          case 'Furigana':
            return card.furigana || card.text; // Fallback to text if generation failed/missing
          case 'Image':
            return imageTag;
          case 'Time':
            return card.timestampStr;
          case 'Audio':
            return audioTag;
          case 'Sequence':
            return safeAudioFilename;
          default:
            return '';
        }
      }
      return "";
    });

    const fldsStr = fieldValues.join(ANKI_SEP);
    const noteId = creationTime + index * 100; // Use creationTime for ID generation too
    const guid = generateGUID(noteId.toString());

    noteStmt.run({
      ':id': noteId,
      ':guid': guid,
      ':mid': noteType.id,
      ':mod': Math.floor(creationTime / 1000),
      ':usn': -1,
      ':tags': "Sub2AnkiAI",
      ':flds': fldsStr,
      ':sfld': card.text, // Sort field (usually first field)
      ':csum': 0, // checksum
      ':flags': 0,
      ':data': ""
    });

    // Create cards for each template
    noteType.templates.forEach((_tpl, tplIdx) => {
      cardStmt.run({
        ':id': noteId + tplIdx + 1,
        ':nid': noteId,
        ':did': deckId,
        ':ord': tplIdx,
        ':mod': Math.floor(creationTime / 1000),
        ':usn': -1,
        ':type': 0,
        ':queue': 0,
        ':due': noteId, // simplistic due number
        ':ivl': 0,
        ':factor': 0,
        ':reps': 0,
        ':lapses': 0,
        ':left': 0,
        ':odue': 0,
        ':odid': 0,
        ':flags': 0,
        ':data': ""
      });
    });
  });

  noteStmt.free();
  cardStmt.free();

  return db.export();
};

// Helper for GUID generation (simplified)
function generateGUID(input: string): string {
  // Simple non-collision hash for this session
  return btoa(input + Math.random().toString()).slice(0, 10);
}
