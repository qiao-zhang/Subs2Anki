import initSqlJs, { Database } from 'sql.js';
import { AnkiCard, AnkiNoteType } from './types';

// Constants for Anki Database
const ANKI_SEP = '\x1f'; // Unit separator for fields

/**
 * Generates the SQLite database (collection.anki2) required for an .apkg file.
 */
export const createAnkiDatabase = async (
  cards: AnkiCard[],
  deckName: string,
  noteType: AnkiNoteType
): Promise<Uint8Array> => {
  const SQL = await initSqlJs({
    // In a real build, you might need to point to the wasm file.
    // esm.sh usually handles this, or we might need a CDN URL.
    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
  });

  const db = new SQL.Database();

  // 1. Create Schema
  db.run(`
    CREATE TABLE col (
      id integer primary key,
      crt integer not null,
      mod integer not null,
      scm integer not null,
      ver integer not null,
      dty integer not null,
      usn integer not null,
      ls integer not null,
      conf text not null,
      models text not null,
      decks text not null,
      dconf text not null,
      tags text not null
    );
    CREATE TABLE notes (
      id integer primary key,
      guid text not null,
      mid integer not null,
      mod integer not null,
      usn integer not null,
      tags text not null,
      flds text not null,
      sfld integer not null,
      csum integer not null,
      flags integer not null,
      data text not null
    );
    CREATE TABLE cards (
      id integer primary key,
      nid integer not null,
      did integer not null,
      ord integer not null,
      mod integer not null,
      usn integer not null,
      type integer not null,
      queue integer not null,
      due integer not null,
      ivl integer not null,
      factor integer not null,
      reps integer not null,
      lapses integer not null,
      left integer not null,
      odue integer not null,
      odid integer not null,
      flags integer not null,
      data text not null
    );
    CREATE TABLE revlog (
      id integer primary key,
      cid integer not null,
      usn integer not null,
      ease integer not null,
      ivl integer not null,
      lastIvl integer not null,
      factor integer not null,
      time integer not null,
      type integer not null
    );
    CREATE TABLE graves (
      usn integer not null,
      oid integer not null,
      type integer not null
    );
    ANALYZE sqlite_master;
  `);

  // 2. Create Deck Configuration (dconf) and Decks
  const deckId = new Date().getTime();
  const finalDeckName = deckName || "Sub2Anki Export";

  const decks = {
    [deckId]: {
      id: deckId,
      mod: Math.floor(Date.now() / 1000),
      name: finalDeckName,
      usn: -1,
      lrnToday: [0, 0],
      revToday: [0, 0],
      newToday: [0, 0],
      timeToday: [0, 0],
      collapsed: false,
      browserCollapsed: false,
      desc: "Generated by Sub2Anki AI",
      dyn: 0,
      conf: 1,
      extendNew: 10,
      extendRev: 50
    },
    // Default deck needed
    1: {
      id: 1,
      name: "Default",
      conf: 1,
      mod: 0,
      usn: 0,
      desc: "",
      dyn: 0,
      collapsed: false,
      browserCollapsed: false,
      extendNew: 10,
      extendRev: 50,
      newToday: [0, 0],
      revToday: [0, 0],
      lrnToday: [0, 0],
      timeToday: [0, 0]
    }
  };

  const dconf = {
    1: {
      id: 1,
      mod: 0,
      name: "Default",
      usn: 0,
      maxTaken: 60,
      autoplay: true,
      timer: 0,
      replayq: true,
      new: { bury: false, delays: [1, 10], initialFactor: 2500, ints: [1, 4, 7], order: 1, perDay: 20 },
      rev: { bury: false, ease4: 1.3, fuzz: 0.05, ivlFct: 1, maxIvl: 36500, minSpace: 1, perDay: 200 },
      lapse: { delays: [10], leechAction: 0, leechFails: 8, minInt: 1, mult: 0 }
    }
  };

  // 3. Create Model (Note Type) Configuration
  // Anki requires specific structure for fields and templates
  const flds = noteType.fields.map((f, i) => ({
    name: f.name,
    ord: i,
    sticky: false,
    rtl: false,
    font: "Arial",
    size: 20,
    media: []
  }));

  const tmpls = noteType.templates.map((t, i) => ({
    name: t.Name,
    ord: i,
    qfmt: t.Front,
    afmt: t.Back,
    bqfmt: "",
    bafmt: "",
    did: null
  }));

  const models = {
    [noteType.id]: {
      id: noteType.id,
      name: noteType.name,
      type: 0,
      mod: Math.floor(Date.now() / 1000),
      usn: -1,
      sortf: 0,
      did: deckId,
      tmpls: tmpls,
      flds: flds,
      css: noteType.css,
      latexPre: "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
      latexPost: "\\end{document}",
      tags: [],
      req: [[0, "all", [0]]] // Require first field to be non-empty
    }
  };

  // 4. Insert Collection
  const colStmt = db.prepare(`INSERT INTO col VALUES (:id, :crt, :mod, :scm, :ver, :dty, :usn, :ls, :conf, :models, :decks, :dconf, :tags)`);
  colStmt.run({
    ':id': 1,
    ':crt': Math.floor(Date.now() / 1000),
    ':mod': Math.floor(Date.now() / 1000),
    ':scm': Math.floor(Date.now() / 1000),
    ':ver': 11,
    ':dty': 0,
    ':usn': 0,
    ':ls': 0,
    ':conf': "{}",
    ':models': JSON.stringify(models),
    ':decks': JSON.stringify(decks),
    ':dconf': JSON.stringify(dconf),
    ':tags': "{}"
  });
  colStmt.free();

  // 5. Insert Notes and Cards
  const noteStmt = db.prepare(`INSERT INTO notes VALUES (:id, :guid, :mid, :mod, :usn, :tags, :flds, :sfld, :csum, :flags, :data)`);
  const cardStmt = db.prepare(`INSERT INTO cards VALUES (:id, :nid, :did, :ord, :mod, :usn, :type, :queue, :due, :ivl, :factor, :reps, :lapses, :left, :odue, :odid, :flags, :data)`);

  let now = Date.now();

  cards.forEach((card, index) => {
    // Generate Fields based on Note Type Mapping
    // We map based on the `source` property of the field.

    // Construct media filename
    const safeImageFilename = card.screenshotDataUrl ? `sub2anki_${index}_${now}.jpg` : '';
    const imageTag = safeImageFilename ? `<img src="${safeImageFilename}">` : '';

    // Prepare fields array based on the model definition and mappings
    const fieldValues: string[] = noteType.fields.map(f => {
      // Use explicit mapping if available
      if (f.source) {
        switch (f.source) {
          case 'Text': return card.text;
          case 'Translation': return card.translation;
          case 'Notes': return card.notes;
          case 'Image': return imageTag;
          case 'Time': return card.timestampStr;
          case 'Audio': return ''; // Placeholder for audio implementation
          case 'Gif': return ''; // Placeholder for gif implementation
          default: return '';
        }
      }

      // Legacy Fallback (Name Heuristics) if no source is mapped
      const name = f.name.toLowerCase();
      if (name.includes('text') || name.includes('sentence') || name.includes('front')) return card.text;
      if (name.includes('translation')) return card.translation;
      if (name.includes('notes')) return card.notes;
      if (name.includes('meaning')) return `${card.translation}<br><small>${card.notes}</small>`;
      if (name.includes('image') || name.includes('screenshot') || name.includes('picture')) return imageTag;
      if (name.includes('time')) return card.timestampStr;

      return "";
    });

    const fldsStr = fieldValues.join(ANKI_SEP);
    const noteId = now + index * 100;
    const guid = generateGUID(noteId.toString());

    noteStmt.run({
      ':id': noteId,
      ':guid': guid,
      ':mid': noteType.id,
      ':mod': Math.floor(now / 1000),
      ':usn': -1,
      ':tags': "Sub2AnkiAI",
      ':flds': fldsStr,
      ':sfld': card.text, // Sort field (usually first field)
      ':csum': 0, // checksum
      ':flags': 0,
      ':data': ""
    });

    // Create cards for each template
    noteType.templates.forEach((tpl, tplIdx) => {
      cardStmt.run({
        ':id': noteId + tplIdx + 1,
        ':nid': noteId,
        ':did': deckId,
        ':ord': tplIdx,
        ':mod': Math.floor(now / 1000),
        ':usn': -1,
        ':type': 0,
        ':queue': 0,
        ':due': noteId, // simplistic due number
        ':ivl': 0,
        ':factor': 0,
        ':reps': 0,
        ':lapses': 0,
        ':left': 0,
        ':odue': 0,
        ':odid': 0,
        ':flags': 0,
        ':data': ""
      });
    });
  });

  noteStmt.free();
  cardStmt.free();

  const data = db.export();
  return data;
};

// Helper for GUID generation (simplified)
function generateGUID(input: string): string {
  // Simple non-collision hash for this session
  return btoa(input + Math.random().toString()).slice(0, 10);
}